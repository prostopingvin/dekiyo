const fs = require('fs');
function isObject(object) { //Проверяет является ли что-то объектом
    if(
        Array.isArray(object) || 
        typeof object !== 'object'
    ) return false;
    if(typeof object == 'object') return true;
}
function _delete(copy, origin) { //Удаляет все ключи с "_" и возвращает новый объект
    for (const key in origin) {
        if(key.slice(0,1) !== "_") {
            copy[key] = origin[key];
            if(isObject(origin[key])) _delete(copy[key], origin[key]);
        }
    }
}
function UpdateCreate(origin, data) { //Устанавливает ключи если их нет
    for (const key in data) {
        if(key.slice(0,1)!=="_")
        if(origin[key] === undefined) origin[key] = data[key];
        else if(isObject(data[key]) && key!=="members") UpdateCreate(origin[key], data[key]);
    }
}
function UpdateDelete(origin, data) { //Удаляет ключи если их быть не должно
    for (const key in origin) {
        if(key.slice(0,1)!=="_")
        if(data[key] === undefined) delete origin[key];
        else if(isObject(data[key]) && key!=="members") UpdateDelete(origin[key], data[key]);
    }
}
const globals = {
    name: "ANY",
    bot: {}
};
class Memory {
    constructor(name = "DiscordDB", Client = null, config = undefined) {
        if(!name) throw "Name is not defined";
        this.name = name;
        if(!Client) throw "Client is not defined";
        globals.bot = Client;
        try {
            this._config = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/config.json`);
        } catch (err) {
            this._config = {
                autoStart: false,
                autoAdd: true,
                autoStartSchems: {
                    guilds: null,
                    users: null,
                    members: null
                },
                backUp: {
                    enable: false,
                    time: 3600000,
                    count: 2
                },
                autoSave: {
                    enable: false,
                    lastRefresh: Date.now(),
                    time: 60000*10
                }
            };
        }
        if(this._config.autoStart) {

            this._config.autoStartSchems.guilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/guilds.js`);
            this._config.autoStartSchems.users = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/users.js`);
            this._config.autoStartSchems.members = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Schems/members.js`);

            if(config) {
                if(config.guilds) this._config.autoStartSchems.guilds = config.guilds;
                if(config.users) this._config.autoStartSchems.users = config.users;
                if(config.members) this._config.autoStartSchems.members = config.members;
            }

            this._memberData = this._config.autoStartSchems.members;
            this._guildData = this._config.autoStartSchems.guilds;
            this._userData = this._config.autoStartSchems.users;

            if(this._guildData) this.setGuilds(this._guildData);
            if(this._userData) this.setUsers(this._userData);
            if(this._memberData) this.setMembers(this._memberData);
            this.setAnyData();
        }
        if(this._config.autoSave.enable) this.setAutoSave(this._config.autoSave.time);
        if(this._config.backUp.enable) this.setBackUp(this._config.backUp.time);
        
        if(this._config.autoAdd) Client.on('messageCreate', message => {
            if(message.guild) {
                if(!this.guilds.get(message.guild.id)) this.guilds.add(message.guild);
                const memGuild = this.guilds.get(message.guild.id,false);
                if(!memGuild.members.get(message.author.id)&&message.member) memGuild.members.add(message.member);
                if(!this.users.get(message.author.id)&&message.author) this.users.add(message.author);
            }
        });
    }
    get consoleClear() {
        const guilds = [],
        members = [],
        users = [];
        if(this.guilds) for (const key in this.guilds) {
            guilds.push(key);
            const guild = this.guilds[key];
            if(guild.members) for (const keys in guild.members) {
                members.push(keys);
            }
        } 
        if(this.users) for (const key in this.users) {
            users.push(key);
        }
        const text = "" +
        ` ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑` + "\n"+
        ` ┝━━┥ Name DB:-------> ${this.name}` + "\n"+
        ` ┝━━┥ Elements:------> ${guilds.length+members.length+users.length} count` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ Guilds:--------> ${guilds.length} count` + "\n"+
        ` ┝━━┥ Members:-------> ${members.length} count` + "\n"+
        ` ┝━━┥ Users:---------> ${users.length} count` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ AutoStart: ${this._config.autoStart?"True":"False"}` + "\n"+
        ` ┝━━┥ BackUP: ${this._config.backUp.enable?"True":"False"}` + "\n"+
        ` ┝━━┥ BackUP Time: ${this._config.backUp.time}` + "\n"+
        ` ┝━━┥ BackUP Count: ${this._config.backUp.count}` + "\n"+
        ` ┝━━┥ AutoSave: ${this._config.autoSave.enable?"True":"False"}` + "\n"+
        ` ┝━━┥ AutoAdd: ${this._config.autoSave.enable?"True":"False"}` + "\n"+
        ` ┝━━┥ SaveTime: ${this._config.autoSave.time}` + "\n"+
        ` ┝━━┥ Schems Guilds: ${this._config.autoStartSchems.guilds?"Enabled":"None"}` + "\n"+
        ` ┝━━┥ Schems Members: ${this._config.autoStartSchems.members?"Enabled":"None"}` + "\n"+
        ` ┝━━┥ Schems Users: ${this._config.autoStartSchems.users?"Enabled":"None"}` + "\n"+
        ` ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙`;

        return text;
    }
    get console() {
        const guilds = [],
        members = [],
        users = [];
        if(this.guilds) for (const key in this.guilds) {
            guilds.push(key);
            const guild = this.guilds[key];
            if(guild.members) for (const keys in guild.members) {
                members.push(keys);
            }
        } 
        if(this.users) for (const key in this.users) {
            users.push(key);
        }
        const text = "" +
        ` ┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑` + "\n"+
        ` ┝━━┥ Name DB:-------> \x1b[33m${this.name}\x1b[0m` + "\n"+
        ` ┝━━┥ Elements:------> \x1b[33m${guilds.length+members.length+users.length} count\x1b[0m` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ Guilds:--------> \x1b[33m${guilds.length} count\x1b[0m` + "\n"+
        ` ┝━━┥ Members:-------> \x1b[33m${members.length} count\x1b[0m` + "\n"+
        ` ┝━━┥ Users:---------> \x1b[33m${users.length} count\x1b[0m` + "\n"+
        ` ┝━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┥` + "\n"+
        ` ┝━━┥ AutoStart: ${this._config.autoStart?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ BackUP: ${this._config.backUp.enable?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ BackUP Time: \x1b[33m${this._config.backUp.time}\x1b[0m` + "\n"+
        ` ┝━━┥ BackUP Count: \x1b[33m${this._config.backUp.count}\x1b[0m` + "\n"+
        ` ┝━━┥ AutoSave: ${this._config.autoSave.enable?"\x1b[32mTrue\x1b[0m":"\x1b[31mFalse\x1b[0m"}` + "\n"+
        ` ┝━━┥ SaveTime: \x1b[33m${this._config.autoSave.time}\x1b[0m` + "\n"+
        ` ┝━━┥ Schems Guilds: ${this._config.autoStartSchems.guilds?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┝━━┥ Schems Members: ${this._config.autoStartSchems.members?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┝━━┥ Schems Users: ${this._config.autoStartSchems.users?"\x1b[32mEnabled\x1b[0m":"\x1b[31mNone\x1b[0m"}` + "\n"+
        ` ┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙`;

        return text;
    }
    get clearData() {
        const newThis = {};
        _delete(newThis, this);
        if(newThis.guilds) {
            newThis.guilds = newThis.guilds.clearData;
            for (const key in newThis.guilds) {
                const guild = newThis.guilds[key];
                guild.members = guild.members.clearData;
            }
        }
        if(newThis.users) newThis.users = newThis.users.clearData;
        return newThis;
    }
    setAutoStart(args) {
        if(args === true) this._config.autoStart = true;
        if(args === false) this._config.autoStart = false;
        return this._config.autoStart;
    }
    _backUp() {
        const time = Date.now(),
        name = this.name,
        data = {},
        anyData = {},
        config = this._config;
        for (const key in this.clearData) {
            const element = this.clearData[key];
            if(["guilds", "users", "name"].includes(key)) data[key] = element;
            else anyData[key] = element;
        }
        fs.mkdirSync(`./${name}/_backUp/${time}`);
        fs.stat(`./${this.name}`, (err) => {
            if (!err) {
                fs.writeFileSync(`./${name}/_backUp/${time}/Memory.json`, JSON.stringify(data, null, '\t'));
                fs.writeFileSync(`./${name}/_backUp/${time}/AnyData.json`, JSON.stringify(anyData, null, '\t'));
                fs.writeFileSync(`./${name}/_backUp/${time}/config.json`, JSON.stringify(config, null, '\t'));
            }
            else if (err.code === 'ENOENT') {
                throw "No patch data!";
            }
        });
        fs.readdir(`./${name}/_backUp`, (err, files) => {
            const dirDellete = files.sort((a,b)=>a-b).slice(0,this._config.backUp.count*-1);
            for (const dir of dirDellete) fs.rmSync(`./${name}/_backUp/${dir}`, { recursive: true });
        });
    }
    setBackUp(args=60000*60) {
        switch(args) {
            case false:
                this._config.backUp.enable = false;
                clearInterval(this._BackUp);
                return;
            case true:
                this._config.backUp.enable = true;
                clearInterval(this._Interval);
                if(this._config.backUp.time>=60000*60) this._Interval = setInterval(() => {
                    this._backUp();
                }, this._config.backUp.time);
                return;
        }
        if(!isNaN(+60000*60)) {
            if(+args<2000) throw "The time can only be more than 3600000";
            this._config.backUp.time = +args;
            this._config.backUp.enable = true;
            clearInterval(this._Interval);
            this._Interval = setInterval(() => {
                this._backUp();
            }, this._config.backUp.time);
        }
    }
    setAutoSave(args=60000*10) {
        switch(args) {
            case false:
                this._config.autoSave.enable = false;
                clearInterval(this._Interval);
                return;
            case true:
                this._config.autoSave.enable = true;
                clearInterval(this._Interval);
                if(this._config.autoSave.time>=60000) this._Interval = setInterval(() => {
                    if(Date.now()-this._config.autoSave.lastRefresh<(this._config.autoSave.time-1000))this.save();
                }, this._config.autoSave.time);
                return;
        }
        if(!isNaN(+args)) {
            if(+args<2000) throw "The time can only be more than 2000";
            this._config.autoSave.time = +args;
            this._config.autoSave.enable = true;
            clearInterval(this._Interval);
            this._Interval = setInterval(() => {
                this.save();
            }, this._config.autoSave.time);
        }
    }
    async create() {
        return new Promise((resolve, reject) => {
            const name = this.name,
            memoryData = {guilds: {}, users: {}},
            configData = {
                autoStart: false,
                autoStartSchems: {
                    guilds: null,
                    users: null,
                    members: null
                },
                backUp: {
                    enable: false,
                    time: 3600000,
                    count: 2
                },
                autoSave: {
                    enable: false,
                    lastRefresh: Date.now(),
                    time: 60000*10
                }
            };
            function create() {
                fs.writeFileSync(`./${name}/Memory.json`, JSON.stringify(memoryData, null, '\t'));
                fs.writeFileSync(`./${name}/AnyData.json`, JSON.stringify({}, null, '\t'));
                fs.writeFileSync(`./${name}/config.json`, JSON.stringify(configData, null, '\t'));
                fs.writeFileSync(`./${name}/Schems/guilds.js`, `module.exports = null`);
                fs.writeFileSync(`./${name}/Schems/members.js`, `module.exports = null`);
                fs.writeFileSync(`./${name}/Schems/users.js`, `module.exports = null`);
            }
            fs.stat(`./${this.name}`, (err) => {
                if (!err) {
                    create();
                    return resolve();	
                }
                else if (err.code === 'ENOENT') {
                    fs.mkdirSync(name);
                    fs.mkdirSync(`./${name}/_backUp`);
                    fs.mkdirSync(`./${name}/Schems`);
                    create();
                    return resolve();
                }
                else reject(err);
            });
        });
    }
    save() {
        const name = this.name,
        data = {},
        anyData = {},
        config = this._config;
        for (const key in this.clearData) {
            const element = this.clearData[key];
            if(["guilds", "users", "name"].includes(key)) data[key] = element;
            else anyData[key] = element;
        }
        this._config.autoSave.lastRefresh = Date.now();
        fs.stat(`./${this.name}`, (err) => {
            if (!err) {
                fs.writeFileSync(`./${name}/Memory.json`, JSON.stringify(data, null, '\t'));
                fs.writeFileSync(`./${name}/AnyData.json`, JSON.stringify(anyData, null, '\t'));
                fs.writeFileSync(`./${name}/config.json`, JSON.stringify(config, null, '\t'));

                if(this._config.autoStartSchems.guilds) fs.writeFileSync(`./${name}/Schems/guilds.js`, `module.exports = ${this._config.autoStartSchems.guilds.toString()};`);
                if(this._config.autoStartSchems.users) fs.writeFileSync(`./${name}/Schems/users.js`, `module.exports = ${this._config.autoStartSchems.users.toString()};`);
                if(this._config.autoStartSchems.members) fs.writeFileSync(`./${name}/Schems/members.js`, `module.exports = ${this._config.autoStartSchems.members.toString()};`);
                
            }
            else if (err.code === 'ENOENT') {
                throw "No patch data!";
            }
        });
    }
    setAnyData() {
        const MemGuilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/AnyData.json`);
        for (const key in MemGuilds) this[key] = MemGuilds[key];
    }
    setGuilds(guildData) {
        const MemGuilds = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Memory.json`).guilds;
        if(guildData) this._config.autoStartSchems.guilds = guildData;
        if(!guildData) guildData = function(guild={id:"None",name:"None"}) {
            return {
                id: guild.id,
                name: guild.name,
                members: {}
            };
        };
        
        class Guilds {
            constructor(guildData, motherData) {
                this._scheme = guildData;
                this._motherData = motherData;
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id];
            }
            add(guilde) {
                if(!guilde) throw "guild is null";
                const guild = this._scheme(guilde);
                this.set(guild);
                return guild;
            }
            set(guilde) {
                this[guilde.id] = new Guild(guilde, this);
                this._motherData.setMembers(this._motherData._memberData, this[guilde.id]);
                return this[guilde.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for (const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class Guild {
            constructor(guilde, motherData) {
                for (const key in guilde) this[key] = guilde[key];
                this._scheme = motherData._scheme;
            }
            set members(value) {
                this._members = value;
            }
            get members() {
                return this._members;
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                newThis.members = this.members;
                return newThis;
            }
            async fetch() {
                return await globals.bot.guilds.fetch(this.id);
            }
            get cache() {
                return globals.bot.guilds.cache.get(this.id);
            }
            get cacheOne() {
                if(globals.bot.guilds.cache.get(this.id)) return globals.bot.guilds.cache.get(this.id);
                else return globals.bot.guilds.fetch(this.id);
            }
        }

        if(!this.guilds) this.guilds = new Guilds(guildData, this);

        const serv = guildData();
        for(let keys in MemGuilds) { //Обновлятель памяти
            const origin = MemGuilds[keys];
            UpdateCreate(origin, serv);
            UpdateDelete(origin, serv);
            this.guilds.set(origin);
        }
    }
    setUsers(userData) {
        const MemUsers = require(require.main.path.replace(/\\/gmi, "/")+`/${this.name}/Memory.json`).users;

        if(userData) this._config.autoStartSchems.users = userData;
        if(!userData) userData = function(user={id:"None",username:"None"}) {
            return {
                id: user.id,
                username: user.username
            };
        };
            
        class Users {
            constructor(userData, motherData) {
                this._scheme = userData;
                
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id];
            }
            add(usere) {
                if(!usere) throw "guild is null";
                const guild = this._scheme(usere);
                this.set(guild);
                return guild;
            }
            set(usere) {
                this[usere.id] = new User(usere, this);
                return this[usere.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for(const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class User {
            constructor(usere, motherData) {
                for (const key in usere) this[key] = usere[key];
                
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            async fetch() {
                return await globals.bot.users.fetch(this.id);
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                return newThis;
            }
            get cache() {
                return globals.bot.users.cache.get(this.id);
            }
            get cacheOne() {
                if(globals.bot.users.cache.get(this.id)) return globals.bot.users.cache.get(this.id);
                else return globals.bot.users.fetch(this.id);
            }
        }

        if(!this.users) this.users = new Users(userData, this);

        const user = userData();
        for(let keys in MemUsers) { //Обновлятель памяти
            const origin = MemUsers[keys];
            UpdateCreate(origin, user);
            UpdateDelete(origin, user);
            this.users.set(origin);
        }
    }
    setMembers(memberData, guild) {
        this._memberData = memberData;
        if(memberData) this._config.autoStartSchems.members = memberData;
        if(!memberData) memberData = function(member={id:"None",user:{username:"None"},guild:{id:"123"}}) {
            return {
                id: member.id,
                username: member.user.username,
                guildId: member.guild.id
            };
        };

        class Members {
            constructor(guildData, motherData, startMembers) {
                this._scheme = guildData;
                this._old = startMembers;
            }
            [Symbol.iterator]() {
                this._iter = {
                    Array: Object.values(this).filter(it=>it.id),
                    current: 0
                };
                return this;
            } 
            next() {
                if (this._iter.current < this._iter.Array.length) {
                    this._iter.current++;
                    return { done: false, value: this._iter.Array[this._iter.current-1]};
                } else {
                    return { done: true };
                }
            }
            update() {
                for (const key in this) {
                    if(key.slice(0,1) !== "_") {
                        const element = this[key];
                        for (let index = 0; index < arguments.length; index++) {
                            const keys = arguments[index];
                            element[keys] = this._scheme(element.cache)[keys];
                        }
                    }	
                }
                return this;
            }
            get(id, clear = false) {
                if(!id) throw "id is null";
                if(clear && this[id]) return this[id].clearData;
                else return this[id];
            }
            add(membere) {
                if(!membere) throw "member is null";
                const guild = this._scheme(membere);
                this.set(guild);
                return guild;
            }
            set(membere) {
                if(membere.id == "123") return;
                this[membere.id] = new Member(membere, this);
                return this[membere.id];
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                for (const key in newThis) 
                    if(Object.hasOwnProperty.call(newThis, key)) newThis[key] = newThis[key].clearData;
                return newThis;
            }
        }

        class Member {
            constructor(membere, motherData) {
                for (const key in membere) this[key] = membere[key];
                
                this._scheme = motherData._scheme;
            }
            update() {
                for (let index = 0; index < arguments.length; index++) {
                    const keys = arguments[index];
                    this[keys] = this._scheme(this.cache)[keys];
                }
                return this;
            }
            async fetch() {
                const guild = globals.bot.guilds.cache.get(this.guildId);
                if(guild && guild.available)
                return await guild.members.fetch(this.id);
            }
            get clearData() {
                const newThis = {};
                _delete(newThis, this);
                return newThis;
            }
            get cache() {
                const guild = globals.bot.guilds.cache.get(this.guildId);
                if(guild && guild.available) return guild.members.cache.get(this.id);
            }
            get cacheOne() {
                const guild = globals.bot.guilds.cache.get(this.guildId);
                if(guild && guild.available) if(guild.members.cache.get(this.id)) return guild.members.cache.get(this.id);
                else guild.members.fetch(this.id);
            }
        }
        
        

        const member = memberData();
        if(guild) {
            guild._members = new Members(memberData, this, guild.members);
            for (const key in guild._members._old) {
                const element = guild._members._old[key];
                UpdateCreate(element, member);
                UpdateDelete(element, member);
                guild._members.set(element);	
            }
            delete guild._members._old;
        }
        else for(let keys in this.guilds) { //Обновлятель памяти
            if(keys.slice(0,1) !== "_") {
                const origin = this.guilds[keys];		
                origin._members = new Members(memberData, this, origin.members);
                for (const key in origin._members._old) {
                    const element = origin._members._old[key];
                    UpdateCreate(element, member);
                    UpdateDelete(element, member);
                    origin._members.set(element);	
                }
                delete origin._members._old;
            }
        }
    }
}
module.exports = Memory;